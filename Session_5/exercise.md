# Scopes, functions and parameter passing

*Static scoping oftens gives better code. Because we do not have to 'analyze' all our variables on runtime.*

## Question 1
```
begin
    var x := 0;
    var y := 42
    proc p is x := x + 3;
    proc q is call p ;
    begin
        var x := 9;
        proc p is x := x +1;
        call q ;
        y := x
    end
end
```

Now imagine that we have mixed scope rules. First consider the case where variables follow
static scope rules whereas procedures follow dynamic scope rules. What is the final value
of y then? And if we instead had dynamic scopes for variables but static scope rules for
procedures?

| Variables | procedures | result
|---------- | ------------| --------
|   static  |    dynamic  |    10
|  dynamic  |     static  |    12


## Question 2 
book on program design claims that in the language Pascal the construct while E do C
is equivalent to calling the procedure

```
procedure whiledo(e : Boolean; procedure c)
    begin
        if e then
            begin c;
                whiledo (e, c)
            end;
    end;
```

where the first parameter is a call-by-value parameter and the second parameter is a
procedure parameter, with the call `whiledo(E,PC)`, where PC is a parameterless procedure
whose body is C.
Why is this incorrect? Suggest a suitable correction

### ANSWER: 
If the procedure sets 'e' to false. It will still be considered true in `whiledo (e, c)`. 
Because 'e' is a call-by-value (a copy). Therefore, it will still call the whiledo function.
`whiledo(e,c)` will run recursively until we get stack overflow.

Correction:
Use call-by-name parameter passing (but Pascal does not have this feature).
Refactor 'e' into a procedure.

#### call-by-*
* call-by-value
    * Where arguments are evaluated before the function call.
* call-by-name
    * The argument expressions are not evaluated before the function call. Instead, the expressions themselves are passed into the function.
    * Whenever the parameter is used within the function, the expression passed as an argument is evaluated in the context of the caller. This means the expression is re-evaluated each time the parameter is accessed.
* call-by-reference
    * Where the function is given access to the actual variables.

## Question 3 
Famous influencer on Instagram proposes to extend his favourite programming language
with formal parameter list definitions of the form

```
parlist mypars = (T1 X1 ,... , Tn Xn)
```

where the 'T1, ..., Tn' are types.
This could save a lot of space. Instead of writing e.g.

```
function f1(T1 X1 ,... , Tn Xn)
... { body of f1 appears here }

function f2(T1 X1 ,... , Tn Xn)
... { body of f2 appears here }
```

we could simply write

```
function f1 (mypars)
... { body of f1 appears here }
function f2 (mypars)
... { body of f2 appears here }
```

Why should the influencer be discouraged?

### ANSWER
Lets say that we define a variable T1 X1 again inbetween f1 and f2. And T1 X1 is also defined in the parameter list.
Then it will not be clear if we are referencing the X1 from the parameter list or the 'new' variable.

## Question 4
Here is an ALGOL60 procedure that returns a real number. Remember that the only parameter passing mechanism in this language is call-by-name.

```
real procedure bingo (k, l, u, ak)
        value l, u;
        integer k, l, u;
        real ak ;
        // comment k and ak are call-by-name formal parameters;
    begin
        real s;
        s := 0;
        for k := l step 1 until u do
            s := s + ak;
        bingo := s // return s
    end;
```

Now let V be a real-valued array with 100 entries.
What happens if we call `bingo(i, 1, 100, V[i])`?

### ANSWER
* `i` will be evaluated before `V[i]`. Therefore it will be out of sync.

# Additional tasks (answers generated by chatGPT)
1. In a language with dynamic scope rules, where is a free identifier in a function definition bound if it does not have a binding occurrence in the context in which it is called?

In a language with dynamic scope rules, a free identifier in a function definition is bound to a variable definition in the calling context, rather than in the textual (lexical) context in which the function is defined. This means that if the identifier does not have a binding occurrence in the context in which the function is called, the interpreter or runtime system will look for a binding in the caller's environment, and if not found there, will continue looking in the caller's caller's environment, and so on, up the call stack.

In dynamic scoping, the binding of variables is determined at runtime based on the sequence of function calls that led to the current point of execution. This is in contrast to lexical (or static) scoping, where bindings are determined at compile time based on the program's textual structure.

So, under dynamic scope, if a free identifier in a function definition does not have a binding occurrence in the context in which it is called, it will be bound to the nearest enclosing variable binding that is available at runtime, following the call chain back through the program's execution context. If no such binding is found in any of the calling contexts, the result depends on the language's behavior for unbound identifiers, which might be an error or some form of default value.

2. Certainly, let's consider an example that illustrates how call-by-name and call-by-reference parameter passing mechanisms are not equivalent. These mechanisms differ fundamentally in how they evaluate function arguments and can lead to different results under specific conditions.

## Example Function
Suppose we have a simple function that increments its argument:
```
function increment(x) {
  x = x + 1;
  return x;
}
```

### Call-by-Reference
In call-by-reference, a function receives an implicit reference to the actual parameter rather than a copy of its value. Changes to the parameter within the function affect the argument used to call the function.

```
let a = 10;
increment(a);
// If we print 'a' after this, its value would be unchanged in a pure call-by-reference scenario.
print(a); // Prints 10 in a pure call-by-reference language (assuming the increment function doesn't actually modify 'a', but let's explore further).
```

However, to truly showcase the difference and make this example align more closely with how call-by-reference would show a difference, consider a scenario where we manipulate the argument through a reference directly:
```
function incrementByReference(x) {
  x.value = x.value + 1;
}

let obj = {value: 10};
incrementByReference(obj);
print(obj.value); // Prints 11 because obj is passed by reference, and its internal state is modified.
```

### Call-by-Name
Call-by-name delays the evaluation of the function argument until its value is used inside the function. It's as if the body of the function is substituted into the calling place, with the actual arguments substituted for the formal parameters.

To contrast with call-by-reference, we need an example where the difference is highlighted, often involving side effects or the evaluation context of the arguments.

```
let a = 10;
function incrementCallByName(x) {
  // Imagine 'x' is substituted directly with 'a + 1' rather than evaluated to its value.
  x = x + 1; // This becomes 'a + 1 = a + 1 + 1' if 'x' was 'a + 1'
  return x;
}

// Calling incrementCallByName with 'a' directly won't show the difference,
// so we need a scenario that would be affected by call-by-name semantics.

// However, creating a direct example in a language not supporting call-by-name natively is challenging.
// The essence is, with call-by-name, if you passed an expression like 'a + 1', it's re-evaluated each time.
```

### Demonstrating the Difference
A more accurate demonstration involves modifying the environment or the evaluation context in a way that call-by-reference and call-by-name would behave differently. The above examples hint at how they might differ, but directly contrasting them requires either using a language that supports both mechanisms or simulating the call-by-name effect in a language that doesn't natively support it, which can be complex due to the need to manually re-evaluate arguments.

The key takeaway is that in call-by-reference, arguments are passed as references, allowing functions to modify the external variable. In contrast, call-by-name re-evaluates the argument expression each time it's used within the function, leading to different behaviors especially in scenarios involving side effects or when the argument's value changes between evaluations within the function.